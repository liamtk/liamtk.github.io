add_row(Category = "  ",
Variable = "Sample Size (Block Groups)",
`Mean Neighborhood` = paste0(mean_neighbourhood),
`Difference (Control 1)` = paste0(mean_group_1),
`Difference (Control 2)` = paste0(mean_group_2)) %>%
# reorder factor levels of Category
mutate(Category = factor(Category, levels = c("Race/Ethnicity",
"Crime",
"Education",
"Income",
"  "))) %>%
# sort
arrange(Category) %>%
group_by(Category) %>%
# remove unwanted rows and cols
filter(Variable != 'Aggregate Income in 2021 dollars') %>%
dplyr::select(-Significance_Group_1, -Significance_Group_2,
-SE_Diff_Group_1, -SE_Diff_Group_2,
-n_Group_1, -n_Group_2, -n_Group_Neighbourhood)
# output to kable latex
means_table_latex <- means_table_formatted_2  %>%
ungroup() %>%
dplyr::select(-Category) %>%
kable("latex", booktabs = TRUE, caption = "El Norte Summary Statistics") %>%
kable_styling(latex_options = "hold_position") %>%
pack_rows(index = table(means_table_formatted_2$Category)) %>%
#add_header_above(c(" " = 2, "Control 1" = 2, "Control 2" = 2)) %>%
add_footnote("Notes: Significance codes: '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1",
threeparttable = TRUE)
save(list = "means_table_latex", file = "means_table_formatted.RData")
blockgroup_wide_crime_plot <- blockgroup_wide_crime %>%
filter(Total_Population > 100)
tmap_mode("view")
## Function to display a rudimentary map to validate our neighbourhood definition
produce_neigbourhood_map <- function(scheme){
tm_shape(blockgroup_wide_crime %>% left_join(scheme, by = "GEOID")) +
tm_borders(lwd = 0.1) +
tm_fill("Share_LatinX", alpha = 0.5) +
tm_shape(hace_locs) +
tm_dots() +
tm_shape(st_as_sf(blockgroup_wide_crime %>%
left_join(scheme, by = "GEOID") %>%
filter(in_neighbourhood), crs = 4326)) +
tm_fill(col = "green", alpha = 0.5, group = "in_neighbourhood")
}
# Create a 0.5-mile buffer around the hace sites
# Note: again, results are sensitive to the choice of the buffered distance
library(units)
hace_locs_buffer_A <- hace_locs %>%
st_transform(crs = 3857) %>% # Transform to a suitable projection for distance calculations
st_buffer(dist = set_units(0.5, mi)) %>% # Buffer with 0.5 mile
st_transform(crs = 4326) # Transform back to the original CRS
blockgroup_scheme_A <- blockgroup_wide_crime %>%
mutate(intersects_buffer  = apply(
st_intersects(blockgroup_wide_crime,
hace_locs_buffer_A,
sparse = FALSE),
1,
any),
in_neighbourhood = intersects_buffer & majority_LatinX) %>%
relocate(c(intersects_buffer, majority_LatinX, in_neighbourhood), .after = 1) %>%
dplyr::select(GEOID, in_neighbourhood) %>%
st_drop_geometry()
#Visually inspect the scheme
produce_neigbourhood_map(blockgroup_scheme_A) +
tm_shape(hace_locs_buffer_A) + tm_borders()
hace_locs_buffer_A <- hace_locs %>%
st_transform(crs = 3857) %>% # Transform to a suitable projection for distance calculations
st_buffer(dist = set_units(0.55, mi)) %>% # Buffer with 0.5 mile
st_transform(crs = 4326) # Transform back to the original CRS
blockgroup_scheme_A <- blockgroup_wide_crime %>%
mutate(intersects_buffer  = apply(
st_intersects(blockgroup_wide_crime,
hace_locs_buffer_A,
sparse = FALSE),
1,
any),
in_neighbourhood = intersects_buffer & majority_LatinX) %>%
relocate(c(intersects_buffer, majority_LatinX, in_neighbourhood), .after = 1) %>%
dplyr::select(GEOID, in_neighbourhood) %>%
st_drop_geometry()
#Visually inspect the scheme
produce_neigbourhood_map(blockgroup_scheme_A) +
tm_shape(hace_locs_buffer_A) + tm_borders()
hace_locs_buffer_A <- hace_locs %>%
st_transform(crs = 3857) %>% # Transform to a suitable projection for distance calculations
st_buffer(dist = set_units(0.6, mi)) %>% # Buffer with 0.5 mile
st_transform(crs = 4326) # Transform back to the original CRS
blockgroup_scheme_A <- blockgroup_wide_crime %>%
mutate(intersects_buffer  = apply(
st_intersects(blockgroup_wide_crime,
hace_locs_buffer_A,
sparse = FALSE),
1,
any),
in_neighbourhood = intersects_buffer & majority_LatinX) %>%
relocate(c(intersects_buffer, majority_LatinX, in_neighbourhood), .after = 1) %>%
dplyr::select(GEOID, in_neighbourhood) %>%
st_drop_geometry()
#Visually inspect the scheme
produce_neigbourhood_map(blockgroup_scheme_A) +
tm_shape(hace_locs_buffer_A) + tm_borders()
## FUNCTION TO CALCULATE DIFFERENCE IN MEANS FOR A SINGLE VARIABLE
library(weights)
calc_diff_means <- function(df, var_name, pop_size_var, category, weights = T){
# Separate data frames for the two groups
in_neighbourhood <- df[df$in_neighbourhood, ]
not_in_neighbourhood <- df[!df$in_neighbourhood, ]
#If the weighting variable is just blockgroups, then don't do weights
if(pop_size_var == 'Blockgroup_Count'){weights = F}
# Perform the weighted t-test if there are weights
if(weights){
test_result <- wtd.t.test(x = in_neighbourhood[[var_name]],
y = not_in_neighbourhood[[var_name]],
weight = in_neighbourhood[[pop_size_var]],
weighty = not_in_neighbourhood[[pop_size_var]],
samedata = FALSE,
alternative = "two.tailed",
mean1 = TRUE,
bootse = TRUE)
}
# Otherwise, assume weights are 1 (e.g. for income variables)
else{
test_result <- wtd.t.test(x = in_neighbourhood[[var_name]],
y = not_in_neighbourhood[[var_name]],
weight = rep(1, nrow(in_neighbourhood)),
weighty = rep(1, nrow(not_in_neighbourhood)),
samedata = FALSE,
alternative = "two.tailed",
mean1 = TRUE,
bootse = TRUE)
}
# Create a data frame with the results
results_df <- data.frame(
Category = category,
Variable = var_name,
Mean_Group_Neighbourhood = test_result$additional['Mean.x'],
Mean_Group_1 = test_result$additional['Mean.y'],
Difference_Group_1 = -test_result$additional['Difference'],
SE_Diff_Group_1 = test_result$additional['Std. Err'],
P_Value_Group_1 = test_result$coefficients['p.value'],
Total_Population_Group_Neighbourhood = sum(in_neighbourhood[[pop_size_var]], na.rm = TRUE),
Total_Population_Group_1 = sum(not_in_neighbourhood[[pop_size_var]], na.rm = TRUE),
n_Group_Neighbourhood = nrow(in_neighbourhood),
n_Group_1 = nrow(not_in_neighbourhood)
)
# Add the significance stars
results_df <- results_df %>%
mutate(Significance_Group_1 = case_when(
P_Value_Group_1 < 0.001 ~ "***",
P_Value_Group_1 < 0.01  ~ "**",
P_Value_Group_1 < 0.05  ~ "*",
P_Value_Group_1 < 0.1   ~ ".",
TRUE             ~ " "
)) %>%
relocate(Significance_Group_1, .after = P_Value_Group_1)
# Fix up total population count for non-weighted variables
if(!weights){
results_df$Total_Population_Group_Neighbourhood = nrow(in_neighbourhood)
results_df$Total_Population_Group_1 = nrow(not_in_neighbourhood)
}
# Remove row names
rownames(results_df) <- NULL
return(results_df)
}
## Read in dictionary of variables for which to compute diff in means
dict <- read_csv("elnorte_vars_dictionary.csv")
## Iterate over the rows of dict and compute diff in means, then join together
# compute diff in means table for neighbourhood scheme A with control group as all other block groups
library(purrr)
means_table <- map_dfr(1:nrow(dict), ~calc_diff_means(
blockgroup_wide_crime %>%
st_drop_geometry() %>%
left_join(blockgroup_scheme_A) %>%
filter(Total_Population > 0),
var_name = dict$var_name[.x],
pop_size_var = dict$pop_size_var[.x],
category = dict$category[.x]
))
# compute diff in means table for neighbourhood scheme A with control group as all other majority latinx blockgroups
means_table_latinx <- map_dfr(1:nrow(dict), ~calc_diff_means(
blockgroup_wide_crime %>%
st_drop_geometry() %>%
left_join(blockgroup_scheme_A) %>%
filter(Total_Population > 0) %>%
filter(majority_LatinX), ### !!! MODIFIED HERE
var_name = dict$var_name[.x],
pop_size_var = dict$pop_size_var[.x],
category = dict$category[.x]
)) %>%
rename_with(~ gsub("Group_1", "Group_2", .))
# join them together
means_table_formatted_1 <- means_table %>%
left_join(dplyr::select(means_table_latinx, Variable, ends_with("Group_2"))) %>%
dplyr::select(-starts_with("Total_Population"),
-starts_with("P_Value"),
-Mean_Group_1,
-Mean_Group_2)
## OUTPUT
library(knitr)
library(kableExtra)
# Provide longer names for variables
proper_names <- c("Median Income in 2021 dollars", "Aggregate Income in 2021 dollars",
"Share Black", "Share White", "Share NonWhite", "Share LatinX",
"Share Latinx and Black", "Share AAPI", "Share Latinx and nonBlack", "Share In Poverty",
"Share Less Than HighSchool", "Share HighSchool Only", "Share Less Than College",
"Share Some College", "Share Any College Degree", "Share Enrolled 18 Plus All",
"Share Enrolled 18 Plus (Black only)", "Share Enrolled 18 Plus (Latinx only)",
"Violent Crime Count", "Violent Crime Per Capita")
# Old names of variables
names(proper_names) <- c("INCO_Median Income in 2021 dollars",
"INCO_Aggregate Income in 2021 dollars",
"Share_Black", "Share_AAPI", "Share_White", "Share_NonWhite", "Share_LatinX",
"Share_LatinX_and_Black", "Share_LatinX_and_nonBlack", "Share_In_Poverty",
"Share_Less_Than_HighSchool", "Share_HighSchool_Only", "Share_Less_Than_College",
"Share_Some_College", "Share_Any_College_Degree", "Share_Enrolled_18_Plus_All",
"Share_Enrolled_18_Plus_Black", "Share_Enrolled_18_Plus_Latinx",
"violent_crime_count", "violent_crime_percap")
# Calculate means of the n_Group_Neighbourhood, n_Group_1 and n_Group_2
mean_neighbourhood <- mean(means_table_formatted_1$n_Group_Neighbourhood, na.rm = TRUE)
mean_group_1 <- mean(means_table_formatted_1$n_Group_1, na.rm = TRUE)
mean_group_2 <- mean(means_table_formatted_1$n_Group_2, na.rm = TRUE)
# Provide longer names for categories
longer_names <- c("Race/Ethnicity", "Income", "Education", "Crime")
names(longer_names) <- c("RACEETH", "ECON", "EDUC", "CRIME")
# Format the table
means_table_formatted_2 <- means_table_formatted_1 %>%
# recode
mutate(Variable = recode(Variable, !!!proper_names)) %>%
# round
mutate(across(starts_with("Mean_"), round, 3),
across(starts_with("SE_Diff_"), round, 3),
across(starts_with("Difference_"), round, 3)) %>%
# round additionally for income variables (0 dp)
mutate(
Mean_Group_Neighbourhood = ifelse(Variable == "Median Income in 2021 dollars", round(Mean_Group_Neighbourhood), Mean_Group_Neighbourhood),
Difference_Group_1 = ifelse(Variable == "Median Income in 2021 dollars", round(Difference_Group_1), Difference_Group_1),
SE_Diff_Group_1 = ifelse(Variable == "Median Income in 2021 dollars", round(SE_Diff_Group_1), SE_Diff_Group_1),
Difference_Group_2 = ifelse(Variable == "Median Income in 2021 dollars", round(Difference_Group_2), Difference_Group_2),
SE_Diff_Group_2 = ifelse(Variable == "Median Income in 2021 dollars", round(SE_Diff_Group_2), SE_Diff_Group_2)
) %>%
# format SEs
mutate(Mean_Group_Neighbourhood = paste0(Mean_Group_Neighbourhood),
Difference_Group_1 = paste0(Difference_Group_1, " (", SE_Diff_Group_1, " ", Significance_Group_1, ")"),
Difference_Group_2 = paste0(Difference_Group_2, " (", SE_Diff_Group_2, " ", Significance_Group_2, ")")) %>%
# rename
mutate(Category = longer_names[Category]) %>%
rename(`Mean Neighborhood` = Mean_Group_Neighbourhood,
`Difference (Control 1)` = Difference_Group_1,
`Difference (Control 2)` = Difference_Group_2) %>%
# make sample size row
add_row(Category = "  ",
Variable = "Sample Size (Block Groups)",
`Mean Neighborhood` = paste0(mean_neighbourhood),
`Difference (Control 1)` = paste0(mean_group_1),
`Difference (Control 2)` = paste0(mean_group_2)) %>%
# reorder factor levels of Category
mutate(Category = factor(Category, levels = c("Race/Ethnicity",
"Crime",
"Education",
"Income",
"  "))) %>%
# sort
arrange(Category) %>%
group_by(Category) %>%
# remove unwanted rows and cols
filter(Variable != 'Aggregate Income in 2021 dollars') %>%
dplyr::select(-Significance_Group_1, -Significance_Group_2,
-SE_Diff_Group_1, -SE_Diff_Group_2,
-n_Group_1, -n_Group_2, -n_Group_Neighbourhood)
# output to kable latex
means_table_latex <- means_table_formatted_2  %>%
ungroup() %>%
dplyr::select(-Category) %>%
kable("latex", booktabs = TRUE, caption = "El Norte Summary Statistics") %>%
kable_styling(latex_options = "hold_position") %>%
pack_rows(index = table(means_table_formatted_2$Category)) %>%
#add_header_above(c(" " = 2, "Control 1" = 2, "Control 2" = 2)) %>%
add_footnote("Notes: Significance codes: '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1",
threeparttable = TRUE)
save(list = "means_table_latex", file = "means_table_formatted.RData")
View(vars)
View(blockgroup_wide_validation)
library(tidyverse)
library(leaflet)
library(htmlwidgets)
library(tidygeocoder)
## WARNINGS
## Make sure to close the 'combined.csv' file before executing this script
## Check the variable "new_places" to see whether the geocode has worked
setwd(dirname(rstudioapi::getActiveDocumentContext()[["path"]]))
## 1 -- Read in data, geocode new places
# read in data
combined <- read_csv("combined.csv")
# geocode new (if no new places, ignore -- it will throw an error)
new_places <- combined %>%
filter(is.na(lat) & is.na(long)) %>%
select(-lat, -long) %>%
geocode(address = place, method = "osm")
combined <- combined %>%
filter(!is.na(lat) & !is.na(long)) %>%
bind_rows(new_places)
## Write out the new combined.csv file
## 2 -- Generate the map
write_csv(combined, "combined.csv")
# set color palette
pal <- colorFactor(
palette = c('blue', 'darkorange1', 'black', 'turquoise4', 'red', 'darkorchid4', 'darkgreen'),
domain = combined$region
)
# make the map
map <- combined %>%
mutate(region = as.factor(region)) %>%
leaflet() %>%
addCircleMarkers(lng = ~ long,
lat = ~ lat,
popup = ~paste("<b>", place, "</b><br>",
"Years visited: ", visited_year,
"<br><img src='", image_url,
"' width='150' height='auto'/>", sep = ""),
color = ~pal(region),
stroke = F,
fillOpacity = 0.7,
radius = 4.5) %>%
addLayersControl(
baseGroups = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldTopoMap"),
options = layersControlOptions(collapsed = FALSE)
) %>%
addProviderTiles("CartoDB.Positron", group = "CartoDB.Positron",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
addProviderTiles("OpenStreetMap", group = "OpenStreetMap",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
addProviderTiles("Esri.WorldTopoMap", group = "Esri.WorldTopoMap",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
leaflet::fitBounds(lng1 = -90, lat1 = -80, lng2 = 90, lat2 = 80) %>%
leaflet.extras::addFullscreenControl() %>%
leaflet.extras::addResetMapButton() %>%
leaflet::setView(lat = 0, lng = 0, zoom = 1)
# display the map
map
# read in data
combined <- read_csv("combined.csv")
# geocode new (if no new places, ignore -- it will throw an error)
new_places <- combined %>%
filter(is.na(lat) & is.na(long)) %>%
select(-lat, -long) %>%
geocode(address = place, method = "osm")
library(tidyverse)
library(leaflet)
library(htmlwidgets)
library(tidygeocoder)
setwd(dirname(rstudioapi::getActiveDocumentContext()[["path"]]))
# read in data
combined <- read_csv("combined.csv")
# geocode new (if no new places, ignore -- it will throw an error)
new_places <- combined %>%
filter(is.na(lat) & is.na(long)) %>%
select(-lat, -long) %>%
geocode(address = place, method = "osm")
library(dplyr)
# geocode new (if no new places, ignore -- it will throw an error)
new_places <- combined %>%
filter(is.na(lat) & is.na(long)) %>%
select(-lat, -long) %>%
geocode(address = place, method = "osm")
# geocode new (if no new places, ignore -- it will throw an error)
new_places <- combined %>%
filter(is.na(lat) & is.na(long)) %>%
dplyr::select(-lat, -long) %>%
geocode(address = place, method = "osm")
combined <- combined %>%
filter(!is.na(lat) & !is.na(long)) %>%
bind_rows(new_places)
## 2 -- Generate the map
write_csv(combined, "combined.csv")
# set color palette
pal <- colorFactor(
palette = c('blue', 'darkorange1', 'black', 'turquoise4', 'red', 'darkorchid4', 'darkgreen'),
domain = combined$region
)
# make the map
map <- combined %>%
mutate(region = as.factor(region)) %>%
leaflet() %>%
addCircleMarkers(lng = ~ long,
lat = ~ lat,
popup = ~paste("<b>", place, "</b><br>",
"Years visited: ", visited_year,
"<br><img src='", image_url,
"' width='150' height='auto'/>", sep = ""),
color = ~pal(region),
stroke = F,
fillOpacity = 0.7,
radius = 4.5) %>%
addLayersControl(
baseGroups = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldTopoMap"),
options = layersControlOptions(collapsed = FALSE)
) %>%
addProviderTiles("CartoDB.Positron", group = "CartoDB.Positron",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
addProviderTiles("OpenStreetMap", group = "OpenStreetMap",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
addProviderTiles("Esri.WorldTopoMap", group = "Esri.WorldTopoMap",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
leaflet::fitBounds(lng1 = -90, lat1 = -80, lng2 = 90, lat2 = 80) %>%
leaflet.extras::addFullscreenControl() %>%
leaflet.extras::addResetMapButton() %>%
leaflet::setView(lat = 0, lng = 0, zoom = 1)
# display the map
map
setwd(dirname(rstudioapi::getActiveDocumentContext()[["path"]]))
## 1 -- Read in data, geocode new places
# read in data
combined <- read_csv("combined.csv")
# geocode new (if no new places, ignore -- it will throw an error)
new_places <- combined %>%
filter(is.na(lat) & is.na(long)) %>%
dplyr::select(-lat, -long) %>%
geocode(address = place, method = "osm")
combined <- combined %>%
filter(!is.na(lat) & !is.na(long)) %>%
bind_rows(new_places)
## Write out the new combined.csv file
## 2 -- Generate the map
write_csv(combined, "combined.csv")
# set color palette
pal <- colorFactor(
palette = c('blue', 'darkorange1', 'black', 'turquoise4', 'red', 'darkorchid4', 'darkgreen'),
domain = combined$region
)
# make the map
map <- combined %>%
mutate(region = as.factor(region)) %>%
leaflet() %>%
addCircleMarkers(lng = ~ long,
lat = ~ lat,
popup = ~paste("<b>", place, "</b><br>",
"Years visited: ", visited_year,
"<br><img src='", image_url,
"' width='150' height='auto'/>", sep = ""),
color = ~pal(region),
stroke = F,
fillOpacity = 0.7,
radius = 4.5) %>%
addLayersControl(
baseGroups = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldTopoMap"),
options = layersControlOptions(collapsed = FALSE)
) %>%
addProviderTiles("CartoDB.Positron", group = "CartoDB.Positron",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
addProviderTiles("OpenStreetMap", group = "OpenStreetMap",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
addProviderTiles("Esri.WorldTopoMap", group = "Esri.WorldTopoMap",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
leaflet::fitBounds(lng1 = -90, lat1 = -80, lng2 = 90, lat2 = 80) %>%
leaflet.extras::addFullscreenControl() %>%
leaflet.extras::addResetMapButton() %>%
leaflet::setView(lat = 0, lng = 0, zoom = 1)
# display the map
map
setwd(dirname(rstudioapi::getActiveDocumentContext()[["path"]]))
## 1 -- Read in data, geocode new places
# read in data
combined <- read_csv("combined.csv")
# geocode new (if no new places, ignore -- it will throw an error)
new_places <- combined %>%
filter(is.na(lat) & is.na(long)) %>%
dplyr::select(-lat, -long) %>%
geocode(address = place, method = "osm")
combined <- combined %>%
filter(!is.na(lat) & !is.na(long)) %>%
bind_rows(new_places)
## Write out the new combined.csv file
## 2 -- Generate the map
write_csv(combined, "combined.csv")
# set color palette
pal <- colorFactor(
palette = c('blue', 'darkorange1', 'black', 'turquoise4', 'red', 'darkorchid4', 'darkgreen'),
domain = combined$region
)
# make the map
map <- combined %>%
mutate(region = as.factor(region)) %>%
leaflet() %>%
addCircleMarkers(lng = ~ long,
lat = ~ lat,
popup = ~paste("<b>", place, "</b><br>",
"Years visited: ", visited_year,
"<br><img src='", image_url,
"' width='150' height='auto'/>", sep = ""),
color = ~pal(region),
stroke = F,
fillOpacity = 0.7,
radius = 4.5) %>%
addLayersControl(
baseGroups = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldTopoMap"),
options = layersControlOptions(collapsed = FALSE)
) %>%
addProviderTiles("CartoDB.Positron", group = "CartoDB.Positron",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
addProviderTiles("OpenStreetMap", group = "OpenStreetMap",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
addProviderTiles("Esri.WorldTopoMap", group = "Esri.WorldTopoMap",
options = providerTileOptions(minZoom = 1, maxZoom = 7)) %>%
leaflet::fitBounds(lng1 = -90, lat1 = -80, lng2 = 90, lat2 = 80) %>%
leaflet.extras::addFullscreenControl() %>%
leaflet.extras::addResetMapButton() %>%
leaflet::setView(lat = 0, lng = 0, zoom = 1)
# display the map
map
# save/write map as widget ----------------------------------------------
map %>% saveWidget('places.html') # save as widget
